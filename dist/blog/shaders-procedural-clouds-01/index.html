<!DOCTYPE html><html lang="en" class="scroll-smooth dark"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="canonical" href="https://varungupta.dev/blog/shaders-procedural-clouds-01/"><!-- Theme Script (runs before page renders to prevent flash) --><script>
      const theme = localStorage.getItem('theme') || 'dark';
      document.documentElement.classList.toggle('dark', theme === 'dark');
    </script><!-- Primary Meta Tags --><title>Procedural 2D Clouds : A mathematical approach to nature | Varun Kumar Gupta</title><meta name="title" content="Procedural 2D Clouds : A mathematical approach to nature | Varun Kumar Gupta"><meta name="description" content="A deep dive into generating procedural clouds using maths, followed by some tips to make them appear volumetric."><meta name="author" content="Varun Kumar Gupta"><!-- Open Graph / Facebook --><meta property="og:type" content="article"><meta property="og:url" content="https://varungupta.dev/blog/shaders-procedural-clouds-01/"><meta property="og:title" content="Procedural 2D Clouds : A mathematical approach to nature | Varun Kumar Gupta"><meta property="og:description" content="A deep dive into generating procedural clouds using maths, followed by some tips to make them appear volumetric."><meta property="og:image" content="https://varungupta.dev/images/og/default.png"><meta property="og:site_name" content="Varun Kumar Gupta"><!-- Twitter --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:url" content="https://varungupta.dev/blog/shaders-procedural-clouds-01/"><meta name="twitter:title" content="Procedural 2D Clouds : A mathematical approach to nature | Varun Kumar Gupta"><meta name="twitter:description" content="A deep dive into generating procedural clouds using maths, followed by some tips to make them appear volumetric."><meta name="twitter:image" content="https://varungupta.dev/images/og/default.png"><!-- Favicon --><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="icon" type="image/x-icon" href="/favicon.ico"><!-- RSS --><link rel="alternate" type="application/rss+xml" title="Varun Kumar Gupta RSS Feed" href="/feed.xml"><!-- Fonts --><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet"><!-- Theme --><meta name="theme-color" content="#1F1F1F"><link rel="stylesheet" href="/_astro/about.Bi4TzYRT.css">
<link rel="stylesheet" href="/_astro/_slug_.Bxvqs4YC.css"></head> <body class="min-h-screen flex flex-col antialiased"> <header class="fixed top-0 left-0 right-0 z-50 glass border-b border-border/50"> <div class="container"> <nav class="flex items-center justify-between h-20"> <!-- Logo --> <a href="/" class="flex items-center gap-3 group"> <div class="w-10 h-10 rounded-lg bg-accent flex items-center justify-center font-bold text-white text-base">
V
</div> <span class="font-semibold text-text-primary group-hover:text-accent transition-colors hidden sm:block"> Varun Kumar Gupta </span> </a> <!-- Desktop Navigation --> <ul class="hidden md:flex items-center gap-1"> <li> <a href="/" class="relative px-4 py-2 text-sm font-medium transition-colors rounded-lg
                  text-text-secondary hover:text-text-primary hover:bg-bg-secondary"> Home  </a> </li><li> <a href="/blog" class="relative px-4 py-2 text-sm font-medium transition-colors rounded-lg
                  text-text-primary"> Blog <span class="absolute bottom-0 left-4 right-4 h-0.5 bg-accent rounded-full"></span> </a> </li><li> <a href="/projects" class="relative px-4 py-2 text-sm font-medium transition-colors rounded-lg
                  text-text-secondary hover:text-text-primary hover:bg-bg-secondary"> Projects  </a> </li><li> <a href="/about" class="relative px-4 py-2 text-sm font-medium transition-colors rounded-lg
                  text-text-secondary hover:text-text-primary hover:bg-bg-secondary"> About  </a> </li><li> <a href="/contact" class="relative px-4 py-2 text-sm font-medium transition-colors rounded-lg
                  text-text-secondary hover:text-text-primary hover:bg-bg-secondary"> Contact  </a> </li> </ul> <!-- Theme Toggle --> <button id="theme-toggle" class="p-2 text-text-secondary hover:text-text-primary transition-colors rounded-lg hover:bg-bg-secondary" aria-label="Toggle theme"> <svg class="w-5 h-5 dark-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path> </svg> <svg class="w-5 h-5 light-icon hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path> </svg> </button> <!-- Mobile Menu Button --> <button id="mobile-menu-button" class="md:hidden p-2 text-text-secondary hover:text-text-primary transition-colors" aria-label="Toggle menu" aria-expanded="false"> <svg class="w-6 h-6 menu-open" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path> </svg> <svg class="w-6 h-6 menu-close hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path> </svg> </button> </nav> </div> <!-- Mobile Menu --> <div id="mobile-menu" class="md:hidden hidden border-t border-border/50"> <div class="container py-4"> <ul class="flex flex-col gap-2"> <li> <a href="/" class="block px-4 py-3 rounded-lg text-sm font-medium transition-colors
                  text-text-secondary hover:bg-bg-secondary hover:text-text-primary"> Home </a> </li><li> <a href="/blog" class="block px-4 py-3 rounded-lg text-sm font-medium transition-colors
                  bg-accent/10 text-accent"> Blog </a> </li><li> <a href="/projects" class="block px-4 py-3 rounded-lg text-sm font-medium transition-colors
                  text-text-secondary hover:bg-bg-secondary hover:text-text-primary"> Projects </a> </li><li> <a href="/about" class="block px-4 py-3 rounded-lg text-sm font-medium transition-colors
                  text-text-secondary hover:bg-bg-secondary hover:text-text-primary"> About </a> </li><li> <a href="/contact" class="block px-4 py-3 rounded-lg text-sm font-medium transition-colors
                  text-text-secondary hover:bg-bg-secondary hover:text-text-primary"> Contact </a> </li> </ul> </div> </div> </header> <!-- Spacer for fixed header --> <div class="h-20"></div> <script type="module">const t=document.getElementById("mobile-menu-button"),c=document.getElementById("mobile-menu"),s=t?.querySelector(".menu-open"),d=t?.querySelector(".menu-close");t?.addEventListener("click",()=>{const e=t.getAttribute("aria-expanded")==="true";t.setAttribute("aria-expanded",String(!e)),c?.classList.toggle("hidden"),s?.classList.toggle("hidden"),d?.classList.toggle("hidden")});const n=document.getElementById("theme-toggle"),l=n?.querySelector(".dark-icon"),i=n?.querySelector(".light-icon");function o(){const e=document.documentElement.classList.contains("dark");l?.classList.toggle("hidden",!e),i?.classList.toggle("hidden",e)}o();n?.addEventListener("click",()=>{const e=document.documentElement.classList.contains("dark");document.documentElement.classList.toggle("dark",!e),localStorage.setItem("theme",e?"light":"dark"),o()});</script> <!-- Social Links Sidebar --> <div class="hidden lg:block fixed left-6 top-1/2 -translate-y-1/2 z-40"> <div class="flex flex-col gap-9"> <a href="https://github.com/VKG5" target="_blank" rel="noopener noreferrer" class="text-text-tertiary hover:text-text-primary hover:scale-125 transition-all duration-300 ease-out transform" aria-label="GitHub"> <svg class="w-8 h-8" fill="currentColor" viewBox="0 0 24 24"> <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path> </svg> </a> <a href="https://linkedin.com/in/varunkumargupta5" target="_blank" rel="noopener noreferrer" class="text-text-tertiary hover:text-text-primary hover:scale-125 transition-all duration-300 ease-out transform" aria-label="LinkedIn"> <svg class="w-8 h-8" fill="currentColor" viewBox="0 0 24 24"> <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"></path> </svg> </a> <a href="https://x.com/Bawa_Gupta_" target="_blank" rel="noopener noreferrer" class="text-text-tertiary hover:text-text-primary hover:scale-125 transition-all duration-300 ease-out transform" aria-label="Twitter"> <svg class="w-8 h-8" fill="currentColor" viewBox="0 0 24 24"> <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"></path> </svg> </a> <a href="mailto:varunkumargupta914@gmail.com" class="text-text-tertiary hover:text-text-primary hover:scale-125 transition-all duration-300 ease-out transform" aria-label="Email"> <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"></path> </svg> </a> </div> </div> <main class="flex-1">  <article class="py-12 md:py-20"> <!-- Header --> <header class="container-narrow mb-12"> <div class="flex items-center gap-3 text-sm text-text-tertiary mb-4"> <a href="/blog/category/shaders" class="link capitalize"> shaders </a> <span>·</span> <time datetime="2025-12-17T00:00:00.000Z"> December 17, 2025 </time> <span>·</span> <span>23 min read</span> </div> <h1 class="heading-1 mb-6">Procedural 2D Clouds : A mathematical approach to nature</h1> <p class="lead mb-6">A deep dive into generating procedural clouds using maths, followed by some tips to make them appear volumetric.</p> <div class="flex flex-wrap gap-2"> <span class="tag"> tutorial </span><span class="tag"> shaders </span><span class="tag"> glsl </span><span class="tag"> clouds </span><span class="tag"> pcg </span><span class="tag"> noise </span> </div>  </header> <!-- Cover image -->  <!-- Content with TOC --> <div class="container relative"> <!-- Main content (centered) --> <div class="max-w-3xl mx-auto"> <div class="prose-custom">  <p>One of the biggest mistakes I made while developing this shader was not considering the computational cost. This cost me 2 days in live-production and a huge headache, but everything worked out
in the end!</p>
<p>Clouds are something that have fascinated me, you, and possibly everyone at one point in their life. Even though they appear 2D in the sky, they actually have a lot of volume and mass to them.
This also means they are computationally heavy to render/generate. My target was to use something that was NOT a volume, and what else would work if not noise! I have a separate blog for different
noises lined up, so keep out an eye ;)</p>
<p>In this breakdown, I’ll walk through a texture-based, optimized 2D cloud shader I wrote in Godot. It’s the system I developed for a recent project at Zitro, and it handles a huge amount of clouds
while maintaining performance. The is not a “cool clouds” shader, rather performance-centric.</p>
<h2 id="non-procedural-noise">Non-Procedural Noise</h2>
<p>The shader is built around a single-texture with <strong>multiple textures packed</strong> into <strong>different channels</strong>. If you are new to image processing, a typical image is usually comprised of <code>RGB channels</code>, usually
represented by <code>JPEG</code>. Often times there is a fourth one as well called <code>Alpha</code>, making the image <code>RGBA</code>, with the following extensions <code>PNG, EXR, TARGA, TIFF</code>. For this shader, the channels are as
follows:</p>
<ul>
<li><strong>Red Channel (R)</strong>: Static shape mask</li>
<li><strong>Green Channel (G)</strong>: Tiled, primary scrollable noise</li>
<li><strong>Blue Channel (B)</strong>: Tiled, secondary scrollable noise</li>
</ul>
<h3 id="why">Why?</h3>
<p>Well, this way we avoid any expensive procedural noise functions and instead rely on <strong>texture lookups</strong>. These are almost always quicker, and since we have all the data in one image (AKA Texture), we only
need one lookup and one load cycle. We can simply access the various channels/sub-textures using <strong>swizzling</strong> in <strong>GLSL (OpenGL Shading Language)</strong>. This is a shorthand notation of extracting data from a container data type such as vec3.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="glsl"><code><span class="line"><span style="color:#F97583">void</span><span style="color:#B392F0"> fragment</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#E1E4E8">    vec4 tex </span><span style="color:#F97583">=</span><span style="color:#B392F0"> texture</span><span style="color:#E1E4E8">(TEXTURE, UV);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">    // Getting red, green, blue channels</span></span>
<span class="line"><span style="color:#E1E4E8">    vec3 tex_rgb </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> tex.rgb;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">    // Getting individual channels</span></span>
<span class="line"><span style="color:#F97583">    float</span><span style="color:#E1E4E8"> red </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> tex.r;</span></span>
<span class="line"><span style="color:#F97583">    float</span><span style="color:#E1E4E8"> green </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> tex.g;</span></span>
<span class="line"><span style="color:#F97583">    float</span><span style="color:#E1E4E8"> blue </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> tex.b;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>You can grab the image below. The funky colours are due to different data present in each channel.</p>
<img src="/images/blog/pcg_clouds_2d/clouds_texture.png" class="w-full rounded-lg border border-border"/>
<div class="grid grid-cols-3 gap-4 my-8"><div><img src="/images/blog/pcg_clouds_2d/clouds_texture_r.png" alt="Red channel - Static shape mask" class="w-full rounded-lg border border-border"/><p class="text-sm text-center mt-2" style="color: var(--color-text-tertiary)">Red: Shape Mask</p></div><div><img src="/images/blog/pcg_clouds_2d/clouds_texture_g.png" alt="Green channel - Primary scrollable noise" class="w-full rounded-lg border border-border"/><p class="text-sm text-center mt-2" style="color: var(--color-text-tertiary)">Green: Primary Noise</p></div><div><img src="/images/blog/pcg_clouds_2d/clouds_texture_b.png" alt="Blue channel - Secondary scrollable noise" class="w-full rounded-lg border border-border"/><p class="text-sm text-center mt-2" style="color: var(--color-text-tertiary)">Blue: Secondary Noise</p></div></div>
<p>If you use <a href="https://www.unrealengine.com/en-US">Unreal Engine</a>/<a href="https://quixel.com/en-US">Quixel</a>, or any major asset shop, this is a very common technique to save texture lookups and memory.
I got introduced to the concept a few years ago, and I haven’t been able to go back, it is truly the simplest optimization for any game.</p>
<h2 id="uniforms---control-without-complexity">Uniforms - Control Without Complexity</h2>
<p>Alright, now we know how to sample a texture. But how do we pass it on to the GPU?</p>
<p><strong>Uniforms!</strong></p>
<p>Uniforms are special variables that act as a bridge between the CPU (Game Engine) and GPU (Shader). They are read-only parameters that remain constant across all vertices or fragments
in a single draw call. Shaders run in parallel on thousands of pixels/vertices simulataneously. They cannot access you script variables directly as they are running on an entirely different
processing environment, the GPU. Uniforms solve this by:</p>
<ul>
<li><strong>Passing data once</strong>: You set a uniform value on the CPU, and every shader invocation sees the same value</li>
<li><strong>Staying constant</strong>: Unlike varying variables (which interpolate between vertices), uniforms don’t change during a single render pass</li>
<li><strong>Being efficient</strong>: One upload, many reads across all parallel threads</li>
</ul>
<h3 id="common-use-cases">Common Use Cases</h3>
<ul>
<li><strong>Textures</strong>: Passing texture samplers (like our shape mask and noise textures)</li>
<li><strong>Colors</strong>: Theme colors, fog colors, etc.</li>
<li><strong>User settings &amp; custom parameters</strong>: Slider values, toggle states</li>
</ul>
<p>In our case, we’ll use a uniform to pass our noise texture and shape mask to the fragment shader, making it accessible for cloud generation. Another great thing about uniforms is that you
can make changes after compilation. A simple comaprison for uniforms can be made with <strong>Material Instance</strong> in Unreal Engine. The shader is <strong>compiled once</strong> and you can have <strong>multiple variations</strong>
for the same using uniforms. Analogous to <strong>polymorphism</strong> in <strong>Object Oriented Programming (OOPs)</strong>.</p>
<h2 id="uv--motion-controls">UV &amp; Motion Controls</h2>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="glsl"><code><span class="line"><span style="color:#6A737D">// Uniforms</span></span>
<span class="line"><span style="color:#F97583">uniform</span><span style="color:#F97583"> vec2</span><span style="color:#E1E4E8"> uv_scale </span><span style="color:#F97583">=</span><span style="color:#F97583"> vec2</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">100</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">75</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// Wind control</span></span>
<span class="line"><span style="color:#F97583">uniform</span><span style="color:#F97583"> vec2</span><span style="color:#E1E4E8"> direction </span><span style="color:#F97583">=</span><span style="color:#F97583"> vec2</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1.0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0.0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">uniform</span><span style="color:#F97583"> float</span><span style="color:#E1E4E8"> cloud_scale </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1.5</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">uniform</span><span style="color:#F97583"> float</span><span style="color:#E1E4E8"> speed : </span><span style="color:#B392F0">hint_range</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">-</span><span style="color:#79B8FF">1.0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1.0</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0.03</span><span style="color:#E1E4E8">;</span></span></code></pre>
<p>These uniforms define the spatial scale and motion of the clouds.</p>
<p><code>uv_scale</code> and <code>cloud_scale</code> is used to scale the UVs. This can cause stretching/squashing along with scaling, which is desired for clouds.</p>
<p><code>direction</code> and <code>speed</code> together define wind movement. They have been separated for granular control over both aspect.</p>
<h2 id="lighting--composition-controls">Lighting &amp; Composition Controls</h2>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="glsl"><code><span class="line"><span style="color:#6A737D">// Artistic Controls</span></span>
<span class="line"><span style="color:#F97583">uniform</span><span style="color:#F97583"> float</span><span style="color:#E1E4E8"> cloud_dark </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0.5</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">uniform</span><span style="color:#F97583"> float</span><span style="color:#E1E4E8"> cloud_light </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0.3</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">uniform</span><span style="color:#F97583"> float</span><span style="color:#E1E4E8"> cloud_cover : </span><span style="color:#B392F0">hint_range</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">-</span><span style="color:#79B8FF">10.0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1.0</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0.2</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">uniform</span><span style="color:#F97583"> float</span><span style="color:#E1E4E8"> cloud_alpha : </span><span style="color:#B392F0">hint_range</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0.0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">3.0</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0.25</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">uniform</span><span style="color:#F97583"> float</span><span style="color:#E1E4E8"> sky_tint : </span><span style="color:#B392F0">hint_range</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0.0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1.0</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0.6</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// Sky Hue</span></span>
<span class="line"><span style="color:#F97583">uniform</span><span style="color:#F97583"> vec4</span><span style="color:#E1E4E8"> sky_colour_01 : hint_color </span><span style="color:#F97583">=</span><span style="color:#F97583"> vec4</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0.2</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0.4</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0.6</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1.0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">uniform</span><span style="color:#F97583"> vec4</span><span style="color:#E1E4E8"> sky_colour_02 : hint_color </span><span style="color:#F97583">=</span><span style="color:#F97583"> vec4</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1.0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0.647</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0.0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1.0</span><span style="color:#E1E4E8">);</span></span></code></pre>
<p>These parameters are <strong>artist-friendly</strong>. As a technical artist and graphics engineer, it is my job to make these shaders/tools <strong>accessible</strong> to the artists.
Parameters are a great way of doing so. I sat down with an artist and managed to get some incredible results based on their tweaking! The eye and experience
of an artist should be respected more than it is nowadays.</p>
<p>Instead of <strong>physically-based lighting</strong>, I use simple scalar parameters to control various aspects of the cloud. This ensures smooth performance in real-time
and avoids reworking noise functions or the shader.</p>
<h2 id="vertex-shader---why-it-exists-here">Vertex Shader - Why It Exists Here?</h2>
<p>The vertex shader runs only <strong>four-times for a quad</strong>, once per vertex. I am using a simple plane to render out the clouds for our project. This is helpful when
you look at the holistic picture. Our target resolution is native <code>2160 x 6000</code>, sometimes even more. Considering I sample the noise texture multiple times,
an average of 15 per fragment, the total number of times I need to sample the texture would be:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="plaintext"><code><span class="line"><span>2160 x 6000 = 12,960,000 (Total fragments)</span></span>
<span class="line"><span>12,960,000 x 15 = 194,400,000 (Texture Samples)</span></span></code></pre>
<p>Phew! That is a VERY large number. Thanks to modern GPUs, these computations do not mean a lot, but if your target is mobile devices, or weaker hardware, this becomes
a problem. <em>Like it did for me, while using procedural noise (Oh yes, the count was almost 30x than this).</em></p>
<p>The vertex shader helps reduce some calculations that will remain constant throughout the lifetime of the shader.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="glsl"><code><span class="line"><span style="color:#6A737D">// flat varying vec2 cloud_uv : No interpolation, use vertex A&#39;s value</span></span>
<span class="line"><span style="color:#F97583">varying</span><span style="color:#F97583"> vec2</span><span style="color:#E1E4E8"> cloud_uv;</span></span>
<span class="line"><span style="color:#F97583">varying</span><span style="color:#F97583"> vec2</span><span style="color:#E1E4E8"> time_vec;</span></span>
<span class="line"><span style="color:#F97583">varying</span><span style="color:#F97583"> float</span><span style="color:#E1E4E8"> aspect_ratio;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">void</span><span style="color:#B392F0"> vertex</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#E1E4E8">	aspect_ratio </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (uv_scale.y </span><span style="color:#F97583">!=</span><span style="color:#79B8FF"> 0.0</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">?</span><span style="color:#E1E4E8"> (uv_scale.x </span><span style="color:#F97583">/</span><span style="color:#E1E4E8"> uv_scale.y) </span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 1.0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">	// Fix aspect ratio so clouds look consistent on different screen sizes</span></span>
<span class="line"><span style="color:#E1E4E8">	cloud_uv </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> UV </span><span style="color:#F97583">*</span><span style="color:#B392F0"> vec2</span><span style="color:#E1E4E8">(aspect_ratio, </span><span style="color:#79B8FF">1.0</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> cloud_scale;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">	// TIME for animating the clouds</span></span>
<span class="line"><span style="color:#E1E4E8">	time_vec </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> TIME </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> speed </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> direction;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Anything that doesn’t need per-pixel precision, such as <em>aspect ratio</em> or time-based offsets, is calculated here and passed down as varyings.</p>
<p>While this may look like an insignificant optimization, but in shaders that are rendered across large screens, these choices add up.</p>
<h3 id="understanding-the-varying-keyword">Understanding the <code>varying</code> keyword</h3>
<p>The <code>varying</code> keyword is a bridge between vertex shader and fragment shader. It gets calculated once per vertex and then gets <em>interpolated</em> across the entire surface for every
fragment (pixel) that gets rendered. Consider the following code snipped:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="glsl"><code><span class="line"><span style="color:#6A737D">// VERTEX SHADER (runs 4 times for a quad)</span></span>
<span class="line"><span style="color:#6A737D">// Computes and send interpolated value to fragment shader</span></span>
<span class="line"><span style="color:#F97583">varying</span><span style="color:#F97583"> vec2</span><span style="color:#E1E4E8"> cloud_uv;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">void</span><span style="color:#B392F0"> vertex</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#6A737D">    // This runs ONLY 4 times (once per corner of the quad)</span></span>
<span class="line"><span style="color:#E1E4E8">    cloud_uv </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> UV </span><span style="color:#F97583">*</span><span style="color:#B392F0"> vec2</span><span style="color:#E1E4E8">(aspect_ratio, </span><span style="color:#79B8FF">1.0</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> cloud_scale;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// FRAGMENT SHADER (runs millions of times)</span></span>
<span class="line"><span style="color:#F97583">varying</span><span style="color:#F97583"> vec2</span><span style="color:#E1E4E8"> cloud_uv;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">void</span><span style="color:#B392F0"> fragment</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#6A737D">    // cloud_uv is automatically interpolated between the 4 vertex values</span></span>
<span class="line"><span style="color:#6A737D">    // So every pixel gets a smoothly blended value</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>When the GPU processed a quad (rectangle):</p>
<ol>
<li>
<p><strong>Vertex Shader</strong> calculates <code>cloud_uv</code> at each of the 4 vertices (corners)</p>
<ul>
<li>Top-left corner: cloud_uv = (0.0, 1.0)</li>
<li>Top-right corner: cloud_uv = (1.0, 1.0)</li>
<li>Bottom-left: cloud_uv = (0.0, 0.0)</li>
<li>Bottom-right: cloud_uv = (1.0, 0.0)</li>
</ul>
</li>
<li>
<p>The GPU automatically interpolates these values across the surface</p>
<ul>
<li>A pixel in the center gets cloud_uv ≈ (0.5, 0.5)</li>
<li>A pixel 25% from the left gets cloud_uv ≈ (0.25, y)</li>
</ul>
</li>
<li>
<p>Fragment Shader receives the interpolated value for each pixel and runs the <code>void fragment()</code> code on each pixel.</p>
</li>
</ol>
<p>Having mentioned <strong>texture lookup</strong> and sampling multiple times, what do they actually mean?</p>
<h3 id="texture-lookup--sampling">Texture Lookup &amp; Sampling</h3>
<p>The act of fetching a particular pixel’s colour (texel) from a texture using UV coordinates. Instead of computing noise
mathematically, the function samples noise directly from a texture channel (As shown above).</p>
<p>The green and blue channels provide two independent noise sources,  which can be layered and animated separately. This
keeps the shader fast and predictable across hardware. Why predictable? Each system’s RNG (Random Number Generator) will
produce a different value, which may cause artifacts or broken textures. The code below is used to sample noise based on
a parameter (channel).</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="glsl"><code><span class="line"><span style="color:#F97583">float</span><span style="color:#B392F0"> texture_noise</span><span style="color:#E1E4E8">(sampler2D </span><span style="color:#FFAB70">tex</span><span style="color:#E1E4E8">, vec2 </span><span style="color:#FFAB70">p</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> channel</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8">(channel </span><span style="color:#F97583">==</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">		return</span><span style="color:#B392F0"> texture</span><span style="color:#E1E4E8">(tex, p).g;</span></span>
<span class="line"><span style="color:#E1E4E8">	} </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">		return</span><span style="color:#B392F0"> texture</span><span style="color:#E1E4E8">(tex, p).b;</span></span>
<span class="line"><span style="color:#E1E4E8">	}</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Texture sampling is the process of using interpolated UV coordinates in the fragment shader to fetch texel values from
a texture. A single texture lookup returns all channels (RGBA) so you can swizzle out the green and blue channels as
independent noise sources for layering and animation. Swizzling is a shorthand in GLSL where you can access various
channels in a container data-type by using:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="glsl"><code><span class="line"><span style="color:#F97583">vec3</span><span style="color:#E1E4E8"> pos </span><span style="color:#F97583">=</span><span style="color:#F97583"> vec3</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0.1</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">-</span><span style="color:#79B8FF">10.3</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">4.0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// Extracting the X, Y, and Z channels and their combinations from a predefined vector</span></span>
<span class="line"><span style="color:#F97583">float</span><span style="color:#E1E4E8"> a </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> pos.x;</span><span style="color:#6A737D"> // The resultant value will be 0.1</span></span>
<span class="line"><span style="color:#F97583">vec2</span><span style="color:#E1E4E8"> b </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> pos.yx;</span><span style="color:#6A737D"> // The resultant vector will be (-10.3, 0.1)</span></span>
<span class="line"><span style="color:#F97583">vec3</span><span style="color:#E1E4E8"> c </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> pos.zzy;</span><span style="color:#6A737D"> // The resultant vector will be (4.0, 4.0, -10.3)</span></span></code></pre>
<p>Swizzling provides you an easy way to grab different components of a data container (for example: color.rgb, pos.xy or
pos.zzx), allowing concise access, reordering and replication of channels.</p>
<h3 id="fractal-brownian-motion-fmb">Fractal Brownian Motion (FMB)</h3>
<p>Adding different iterations of noise <em>(octaves)</em>, where we sample the noise at different scales, rotations, and decreasing amplitude. This way
we get more granulatiry in the noise and get more fine detail. This technique is called **Fractal Browning Motion (fBM), or simply,
fractal noise. The following code achieves the same:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="glsl"><code><span class="line"><span style="color:#6A737D">// Rotation matrix for FBM layers</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#F97583"> mat2</span><span style="color:#E1E4E8"> m </span><span style="color:#F97583">=</span><span style="color:#F97583"> mat2</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">vec2</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1.6</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1.2</span><span style="color:#E1E4E8">), </span><span style="color:#B392F0">vec2</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">-</span><span style="color:#79B8FF">1.2</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1.6</span><span style="color:#E1E4E8">));</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">float</span><span style="color:#B392F0"> fbm</span><span style="color:#E1E4E8">(sampler2D </span><span style="color:#FFAB70">tex</span><span style="color:#E1E4E8">, vec2 </span><span style="color:#FFAB70">n</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> channel</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">	float</span><span style="color:#E1E4E8"> total </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0.0</span><span style="color:#E1E4E8">, amplitude </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0.1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">	for</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> i</span><span style="color:#F97583">=</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&lt;</span><span style="color:#79B8FF"> 4</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">		total </span><span style="color:#F97583">+=</span><span style="color:#B392F0"> texture_noise</span><span style="color:#E1E4E8">(tex, n, channel) </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> amplitude;</span></span>
<span class="line"><span style="color:#E1E4E8">		n </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> m </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> n;</span></span>
<span class="line"><span style="color:#E1E4E8">		amplitude </span><span style="color:#F97583">*=</span><span style="color:#79B8FF"> 0.4</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">	}</span></span>
<span class="line"><span style="color:#F97583">	return</span><span style="color:#E1E4E8"> total;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Here <code>m</code> is a constant matrix, which helps break visible tiling while keeping the math minimal.</p>
<h3 id="animated-noise">Animated Noise</h3>
<p>This function builds animated noise by repeatedly samplign the texture while progressively altering UVs and weights. This function is the
<em>heart</em> of the shader.</p>
<p>By exposing various parameters, the same function can be reused for:</p>
<ul>
<li>Cloud Shape</li>
<li>Detail Breakup</li>
<li>Colour Variation</li>
</ul>
<p>For our use case, we have used a extracted the colours extracts from the sky. This is done in the <code>void fragment()</code> function. Below you can find the
noise animation function that I have used for generating the clouds:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="glsl"><code><span class="line"><span style="color:#6A737D">// Optimized animation function using texture lookups</span></span>
<span class="line"><span style="color:#F97583">float</span><span style="color:#B392F0"> animate_noise</span><span style="color:#E1E4E8">(sampler2D </span><span style="color:#FFAB70">tex</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> channel</span><span style="color:#E1E4E8">, vec2 </span><span style="color:#FFAB70">time_offset</span><span style="color:#E1E4E8">, vec2 </span><span style="color:#FFAB70">uv</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">float</span><span style="color:#FFAB70"> q</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">float</span><span style="color:#FFAB70"> uv_step</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">float</span><span style="color:#FFAB70"> weight</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">float</span><span style="color:#FFAB70"> weight_step</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> steps</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">	float</span><span style="color:#E1E4E8"> val </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0.0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">	vec2 uv2 </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> uv </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> uv_step </span><span style="color:#F97583">-</span><span style="color:#E1E4E8"> q </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> time_offset;</span></span>
<span class="line"><span style="color:#E1E4E8">	</span></span>
<span class="line"><span style="color:#F97583">	for</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&lt;</span><span style="color:#E1E4E8"> steps; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">		val </span><span style="color:#F97583">+=</span><span style="color:#B392F0"> abs</span><span style="color:#E1E4E8">(weight </span><span style="color:#F97583">*</span><span style="color:#B392F0"> texture_noise</span><span style="color:#E1E4E8">(tex, uv2, channel));</span></span>
<span class="line"><span style="color:#E1E4E8">		uv2 </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> m </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> uv2 </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> time_offset;</span></span>
<span class="line"><span style="color:#E1E4E8">		weight </span><span style="color:#F97583">*=</span><span style="color:#E1E4E8"> weight_step;</span></span>
<span class="line"><span style="color:#E1E4E8">	}</span></span>
<span class="line"><span style="color:#E1E4E8">	</span></span>
<span class="line"><span style="color:#F97583">	return</span><span style="color:#E1E4E8"> val;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h2 id="fragment-shader---putting-it-all-together">Fragment Shader - Putting it All Together</h2>
<p>Below is a detailed breakdown of the fragment shader used.</p>
<h3 id="masking">Masking</h3>
<p>The red channel of our sampled texture defines a mask where the clouds are allowed to exist. This keeps the edges clean, smooth,
and avoids procedural noise bleeding outside the intended shape.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="glsl"><code><span class="line"><span style="color:#F97583">float</span><span style="color:#E1E4E8"> mask </span><span style="color:#F97583">=</span><span style="color:#B392F0"> texture</span><span style="color:#E1E4E8">(TEXTURE, UV).r;</span></span></code></pre>
<p>Using the shape is as simple as multiplying the alpha of the final image with this mask.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="glsl"><code><span class="line"><span style="color:#E1E4E8">COLOR.a </span><span style="color:#F97583">*=</span><span style="color:#E1E4E8"> mask;</span></span></code></pre>
<p>This circumvents the need to write any edge blending logic and blurring/lowering opacity; at the cost of some memory. Below you
can see the difference between having a mask and not. The left image (without mask) shows harsh edges and seams between textures.
The right image (with mask) solves this issue, giving a much more natural result.</p>
<div class="grid grid-cols-2 gap-4 my-8"><div><img src="/images/blog/pcg_clouds_2d/without_mask.png" alt="Without Mask - Clouds rendered on a plane without applying mask" class="w-full rounded-lg border border-border"/><p class="text-sm text-center mt-2" style="color: var(--color-text-tertiary)">Without Mask</p></div><div><img src="/images/blog/pcg_clouds_2d/with_mask.png" alt="With Mask - Clouds rendered on a plane with the mask" class="w-full rounded-lg border border-border"/><p class="text-sm text-center mt-2" style="color: var(--color-text-tertiary)">With Mask</p></div></div>
<h3 id="noise-construction">Noise Construction</h3>
<p>I first build a base FBM signal <code>q</code>, then layer ridged and smooth noise on top of it. By sampling different noise textures between each noise sample, it gives more natural,
randomized results, breaking tiling, and adding visual complexity.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="glsl"><code><span class="line"><span style="color:#6A737D">// 0. Base FBM (Pass TEXTURE sampler)</span></span>
<span class="line"><span style="color:#F97583">float</span><span style="color:#E1E4E8"> q </span><span style="color:#F97583">=</span><span style="color:#B392F0"> fbm</span><span style="color:#E1E4E8">(TEXTURE, cloud_uv </span><span style="color:#F97583">*</span><span style="color:#79B8FF"> 0.5</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span></code></pre>
<p>Here, a low-frequency FBM noise at half the UV scale is generated. This is used to <strong>wrap/distort</strong> UV coordinates of subsequent noise layers, adding organic irregularity. The <code>0</code> means
it samples the <strong>green channel</strong>.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="glsl"><code><span class="line"><span style="color:#6A737D">// 1. Ridged Noise Shape (Pass TEXTURE sampler)</span></span>
<span class="line"><span style="color:#F97583">float</span><span style="color:#E1E4E8"> r </span><span style="color:#F97583">=</span><span style="color:#B392F0"> animate_noise</span><span style="color:#E1E4E8">(TEXTURE, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, time_vec, cloud_uv, q, </span><span style="color:#79B8FF">1.0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0.8</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0.7</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">4</span><span style="color:#E1E4E8">);</span></span></code></pre>
<p>This call generates the primary clouds shape using ridged noise (<code>abs()</code> in <code>animate_noise</code>). This means that the valleys become peaks, giving sharp clouds edges.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="glsl"><code><span class="line"><span style="color:#6A737D">// 2. Noise Shape (Pass TEXTURE sampler)</span></span>
<span class="line"><span style="color:#F97583">float</span><span style="color:#E1E4E8"> f </span><span style="color:#F97583">=</span><span style="color:#B392F0"> animate_noise</span><span style="color:#E1E4E8">(TEXTURE, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, time_vec </span><span style="color:#F97583">*</span><span style="color:#79B8FF"> 2.0</span><span style="color:#E1E4E8">, cloud_uv, q, </span><span style="color:#79B8FF">1.0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0.7</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0.6</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">4</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">f </span><span style="color:#F97583">*=</span><span style="color:#E1E4E8"> r </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> f;</span></span></code></pre>
<p>This function generated secondary detail noise that moves twice as fast, <code>time_vec * 2.0</code>. It samples the noise in the blue channel, and has a slightly softer falloff. I am then combining
both the noise layers non-linearly:</p>
<ul>
<li><code>r + f</code> = Ridged shape + detail noise.</li>
<li><code>f *= (r + f)</code> = Detail noise is <strong>amplified</strong> where clouds exist.</li>
</ul>
<p>This creates <strong>denser detail in cloud areas</strong> and fade details in empty regions. It’s a cheap way to fake volumetri density, clouds look thicker and more detailed in their centers.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="glsl"><code><span class="line"><span style="color:#6A737D">// 3. Noise Colour (Pass TEXTURE sampler)</span></span>
<span class="line"><span style="color:#F97583">float</span><span style="color:#E1E4E8"> c </span><span style="color:#F97583">=</span><span style="color:#B392F0"> animate_noise</span><span style="color:#E1E4E8">(TEXTURE, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, time_vec </span><span style="color:#F97583">*</span><span style="color:#79B8FF"> 5.0</span><span style="color:#E1E4E8">, cloud_uv, q, </span><span style="color:#79B8FF">2.0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0.4</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0.6</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">);</span></span></code></pre>
<p>This generates a fast-moving, high-frequency noise for colour/brightness variation. This moved 5x faster than base clouds (<code>time_vec * 5.0</code>), creating a shimmer effect. This adds <strong>internal cloud lighing variation</strong>,
same parts darker, some brighter.</p>
<p>Each layer runs at a different speed and scale, which creates the illusion of depth and evolving volume.</p>
<h3 id="colour--composition">Colour &amp; Composition</h3>
<p>The sky gradient is vertical and intentionally simple. The focus of the shader is motion and silhouette, not atmosphere scattering. <em>I am pretty interested in this as well, maybe a future blog?!</em></p>
<p>The <code>mix()</code> function is used to generate a gradient, simply based on 2 uniform colours.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="glsl"><code><span class="line"><span style="color:#F97583">uniform</span><span style="color:#F97583"> vec4</span><span style="color:#E1E4E8"> sky_colour_01 : hint_color </span><span style="color:#F97583">=</span><span style="color:#F97583"> vec4</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0.2</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0.4</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0.6</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1.0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">uniform</span><span style="color:#F97583"> vec4</span><span style="color:#E1E4E8"> sky_colour_02 : hint_color </span><span style="color:#F97583">=</span><span style="color:#F97583"> vec4</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1.0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0.647</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0.0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1.0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">void</span><span style="color:#B392F0"> fragment</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#E1E4E8">    vec3 sky_colour </span><span style="color:#F97583">=</span><span style="color:#B392F0"> mix</span><span style="color:#E1E4E8">(sky_colour_02.rgb, sky_colour_01.rgb, UV.y);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Here <code>UV.y = 0</code> is the bottom and render <code>sky_colour_02</code>; <code>UV.y = 1</code>, the top renders <code>sky_colour_01</code>. The <code>mix()</code> function <strong>linearly</strong> interpolates between them.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="glsl"><code><span class="line"><span style="color:#F97583">vec3</span><span style="color:#E1E4E8"> cloud_colour </span><span style="color:#F97583">=</span><span style="color:#F97583"> vec3</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1.1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1.1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0.9</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">*</span><span style="color:#79B8FF"> clamp</span><span style="color:#E1E4E8">((cloud_dark </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> cloud_light </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> c), </span><span style="color:#79B8FF">0.0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1.0</span><span style="color:#E1E4E8">);</span></span></code></pre>
<p>Using the <code>cloud_colour</code>, I get <strong>subtle internal brightness variation</strong>. The uniforms defined on top control the look and feel for the same.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="glsl"><code><span class="line"><span style="color:#F97583">uniform</span><span style="color:#F97583"> float</span><span style="color:#E1E4E8"> cloud_dark </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0.5</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">uniform</span><span style="color:#F97583"> float</span><span style="color:#E1E4E8"> cloud_light </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0.3</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">uniform</span><span style="color:#F97583"> float</span><span style="color:#E1E4E8"> cloud_cover : </span><span style="color:#B392F0">hint_range</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">-</span><span style="color:#79B8FF">10.0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1.0</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0.2</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">uniform</span><span style="color:#F97583"> float</span><span style="color:#E1E4E8"> cloud_alpha : </span><span style="color:#B392F0">hint_range</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0.0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">3.0</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0.25</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">void</span><span style="color:#B392F0"> fragment</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#E1E4E8">    f </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> cloud_cover </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> cloud_alpha </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> f </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> r;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>I am recalculating the cloud density <code>f</code>. The calculations above control <strong>how much clouds exist</strong> at each pixel.</p>
<ul>
<li><code>cloud_cover</code> = Base amount of clouds (negative = less clouds).</li>
<li><code>cloud_alpha * f * r</code> = Shape noise × ridged noise, scaled by alpha.</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="glsl"><code><span class="line"><span style="color:#F97583">float</span><span style="color:#E1E4E8"> alpha </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> clamp</span><span style="color:#E1E4E8">(f </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> c, </span><span style="color:#79B8FF">0.0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1.0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">vec3</span><span style="color:#E1E4E8"> result </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> mix</span><span style="color:#E1E4E8">(sky_colour, </span><span style="color:#B392F0">clamp</span><span style="color:#E1E4E8">(sky_tint </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> sky_colour </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> cloud_colour, </span><span style="color:#79B8FF">0.0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1.0</span><span style="color:#E1E4E8">), alpha);</span></span></code></pre>
<p><code>result</code> gives us the final <code>rgb</code> colours for our clouds. This takes into accoun the sky’s colour. <code>sky_tint</code> controls the tint factor on the clouds. The final mix is done using the calculated <code>alpha</code>, which
is the cloud coverage mask. Wherever <code>f + c</code> is high, show clouds and vice versa.</p>
<p>Finally the end result is achieved by combining the resultant colour and alphas into a <code>vec4</code>.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="glsl"><code><span class="line"><span style="color:#E1E4E8">COLOR </span><span style="color:#F97583">=</span><span style="color:#F97583"> vec4</span><span style="color:#E1E4E8">(result, alpha </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> mask);</span></span></code></pre>
<h3 id="important-note">Important Note!</h3>
<p>This shader only renders the clouds and not the sky background. If you want to render the sky in the background as well, then you have to modify the final output to the following:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="glsl"><code><span class="line"><span style="color:#E1E4E8">COLOR </span><span style="color:#F97583">=</span><span style="color:#F97583"> vec4</span><span style="color:#E1E4E8">(result, mask);</span></span></code></pre>
<p>What this does is use the mask as the alpha. You can also use <code>COLOR = vec4(result, 1.0)</code>, if you don’t want a soft falloff to the scene.</p>
<h2 id="optimization-viewport-rendering-upscaling">Optimization (Viewport Rendering, Upscaling)</h2>
<p>This is by-far one of the most important section of this breakdown. Rendering at the local <code>2160 x 6000</code> resolution was causing a huge
performance drop. The solution? Very simple, and probably intuitive. In this age of AI and upscaling, we will use the same. I am using
Godot, which is an amazing open-source engine, for this task. The same concept can be used in any game engine using <strong>Render Targets</strong>.
Render Targets are Dynamic 2D Textures, whose content can be updated during runtime. They are useful for a bunch of things, for example,
a painting/drawing board in game. In Godot the hierarchy is as follows:</p>
<div class="my-8 p-6 rounded-lg border border-border" style="background-color:var(--color-bg-secondary)"><div class="flex flex-col items-center gap-6"><div class="flex flex-col items-center"><div class="px-6 py-3 rounded-lg shadow-md border-2" style="background-color:rgba(47, 195, 247, 0.1);border-color:var(--color-accent)"><span class="font-semibold text-lg" style="color:var(--color-accent)">Node2D</span></div><div class="w-0.5 h-8" style="background-color:var(--color-border)"></div></div><div class="flex gap-12"><div class="flex flex-col items-center"><div class="w-0.5 h-6" style="background-color:var(--color-border)"></div><div class="px-5 py-2.5 rounded-lg shadow-sm border-2 transition-colors hover:border-accent" style="background-color:var(--color-bg-primary);border-color:var(--color-border)"><span class="font-medium" style="color:var(--color-text-primary)">TextureRect</span></div></div><div class="flex flex-col items-center"><div class="w-0.5 h-6" style="background-color:var(--color-border)"></div><div class="px-5 py-2.5 rounded-lg shadow-sm border-2" style="background-color:var(--color-bg-primary);border-color:var(--color-border)"><span class="font-medium" style="color:var(--color-text-primary)">Viewport</span></div><div class="w-0.5 h-8" style="background-color:var(--color-border)"></div><div class="px-5 py-2.5 rounded-lg shadow-sm border-2" style="background-color:rgba(47, 195, 247, 0.05);border-color:rgba(47, 195, 247, 0.5)"><span class="font-medium" style="color:var(--color-accent)">Clouds.tscn</span></div></div></div></div><p class="text-sm text-center mt-6" style="color:var(--color-text-tertiary)"><p>Godot Scene Hierarchy for Cloud Rendering</p></p></div>
<p>Here <code>Node2D</code> is the root of the scene, which acts as a container for all children node. In the texture rect I have created a <code>ViewportTexture</code>, which renders the <code>Viewport</code> node in a larger size. Godot
provides basic anti-aliasing algorithms such as <strong>FXAA, MSAA</strong>. This is a very basic method for upscaling and can be improved upon further with custom upscaling algorithms. One can create a custom node
with the required features. For my <code>Clouds.tscn</code> scene I have rendered the clouds in 3 layers with different properties and resolutions. The layers are as follows:</p>
<h3 id="horizon-clouds">Horizon Clouds</h3>
<p>These clouds are the farthest from the viewer’s perspective. I’ve squashed the rectangle so the clouds appear compressed, faking a horizon effect. The size of the rectangle is <code>558 × 200</code>, which means:</p>
<p><code>558 × 200 = 111,600 pixels/fragments</code></p>
<p>With the optimized shader logic averaging <strong>~15 texture samples per fragment</strong> (across FBM + animated noise layers), the total computation becomes:</p>
<p><code>111,600 × 15 = 1,674,000 texture samples</code></p>
<p>The settings I’ve used for colours, and other exposed parameters of the shader are given below. These settings completely depend on the artistic intent of the scene, so feel free to play around!</p>
<img src="/images/blog/pcg_clouds_2d/bottom_clouds_params.png" class="w-full rounded-lg border border-border"/>
<h3 id="middle-clouds">Middle Clouds</h3>
<p>These clouds act as a middle-ground and move a bit faster than the background clouds to fake parallax. For this a rectangle of size <code>563 x 308</code> has been used. The clouds are slightly compressed.</p>
<p><code>563 x 308 = 173,404 pixels/fragments</code></p>
<p><code>173,404 x 15 = 2,601,060 texture samples</code></p>
<p>The shader parameters are given below:</p>
<img src="/images/blog/pcg_clouds_2d/mid_clouds_params.png" class="w-full rounded-lg border border-border"/>
<h3 id="foreground-clouds">Foreground Clouds</h3>
<p>These clouds make up the main focal point of the scene, these clouds will have the most details visible. The are rendered across a rectangle of size <code>574 x 500</code></p>
<p><code>574 x 500 = 287,000 pixels/fragments</code></p>
<p><code>287,000 x 15 = 4,305,000 texture samples</code></p>
<p>These clouds have a lot of detail and move the fastest across the screen, giving a fake sense of depth.  The shader parameters are given below:</p>
<img src="/images/blog/pcg_clouds_2d/top_clouds_params.png" class="w-full rounded-lg border border-border"/>
<p>Calculating the total samples based on the above calculations, we get:</p>
<p><code>4,305,000 + 2,601,060 + 1,674,000 = 8,580,060 samples</code></p>
<p>This is dramatically lower than rendering at full <code>2160 × 6000</code> resolution, which would require <strong>194,400,000 samples</strong>. The loss in quality is also barely visible! Ingenious right? A simple trick can save
your butt at times of crunch.</p>
<h2 id="closing-section">Closing Section</h2>
<p>The shader is not about realism, it’s about <strong>control</strong>, <strong>performance</strong>, and <strong>readability</strong>.</p>
<p>By relying on texture-packed noise and pushing work into the vertex stage, the shader stays lightweight while remanining visually flexible.</p>
<p>This approach works especially well for 2D skies, parallax backgrounds, and UI-driven scenes where full volumetric clouds would be
un-necessary overhead.</p>
<hr/>
<p><em>Have questions about this approach? Find me on Twitter or shoot me an email :)</em></p>  </div> </div> <!-- Sidebar TOC (desktop, fixed positioned on right) --> <aside id="toc-sidebar" class="hidden xl:block fixed right-8 top-32 w-64 overflow-y-auto no-scrollbar pb-8 transition-all duration-200" style="max-height: calc(100vh - 10rem);"> <nav class="text-sm"><h4 class="font-semibold text-text-primary mb-4">On this page</h4><ul class="space-y-2"><li class><a href="#non-procedural-noise" class="block text-text-tertiary hover:text-text-primary transition-colors py-1">Non-Procedural Noise</a></li><li class="ml-4"><a href="#why" class="block text-text-tertiary hover:text-text-primary transition-colors py-1">Why?</a></li><li class><a href="#uniforms---control-without-complexity" class="block text-text-tertiary hover:text-text-primary transition-colors py-1">Uniforms - Control Without Complexity</a></li><li class="ml-4"><a href="#common-use-cases" class="block text-text-tertiary hover:text-text-primary transition-colors py-1">Common Use Cases</a></li><li class><a href="#uv--motion-controls" class="block text-text-tertiary hover:text-text-primary transition-colors py-1">UV &amp; Motion Controls</a></li><li class><a href="#lighting--composition-controls" class="block text-text-tertiary hover:text-text-primary transition-colors py-1">Lighting &amp; Composition Controls</a></li><li class><a href="#vertex-shader---why-it-exists-here" class="block text-text-tertiary hover:text-text-primary transition-colors py-1">Vertex Shader - Why It Exists Here?</a></li><li class="ml-4"><a href="#understanding-the-varying-keyword" class="block text-text-tertiary hover:text-text-primary transition-colors py-1">Understanding the varying keyword</a></li><li class="ml-4"><a href="#texture-lookup--sampling" class="block text-text-tertiary hover:text-text-primary transition-colors py-1">Texture Lookup &amp; Sampling</a></li><li class="ml-4"><a href="#fractal-brownian-motion-fmb" class="block text-text-tertiary hover:text-text-primary transition-colors py-1">Fractal Brownian Motion (FMB)</a></li><li class="ml-4"><a href="#animated-noise" class="block text-text-tertiary hover:text-text-primary transition-colors py-1">Animated Noise</a></li><li class><a href="#fragment-shader---putting-it-all-together" class="block text-text-tertiary hover:text-text-primary transition-colors py-1">Fragment Shader - Putting it All Together</a></li><li class="ml-4"><a href="#masking" class="block text-text-tertiary hover:text-text-primary transition-colors py-1">Masking</a></li><li class="ml-4"><a href="#noise-construction" class="block text-text-tertiary hover:text-text-primary transition-colors py-1">Noise Construction</a></li><li class="ml-4"><a href="#colour--composition" class="block text-text-tertiary hover:text-text-primary transition-colors py-1">Colour &amp; Composition</a></li><li class="ml-4"><a href="#important-note" class="block text-text-tertiary hover:text-text-primary transition-colors py-1">Important Note!</a></li><li class><a href="#optimization-viewport-rendering-upscaling" class="block text-text-tertiary hover:text-text-primary transition-colors py-1">Optimization (Viewport Rendering, Upscaling)</a></li><li class="ml-4"><a href="#horizon-clouds" class="block text-text-tertiary hover:text-text-primary transition-colors py-1">Horizon Clouds</a></li><li class="ml-4"><a href="#middle-clouds" class="block text-text-tertiary hover:text-text-primary transition-colors py-1">Middle Clouds</a></li><li class="ml-4"><a href="#foreground-clouds" class="block text-text-tertiary hover:text-text-primary transition-colors py-1">Foreground Clouds</a></li><li class><a href="#closing-section" class="block text-text-tertiary hover:text-text-primary transition-colors py-1">Closing Section</a></li></ul></nav> </aside> </div> <!-- Post footer --> <footer class="container-narrow mt-16 pt-8 border-t border-border"> <div class="flex items-center justify-between"> <a href="/blog" class="link-underline text-text-secondary hover:text-text-primary">
← Back to Blog
</a> <div class="flex items-center gap-4"> <span class="text-sm text-text-tertiary">Share:</span> <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fvarungupta.dev%2Fblog%2Fshaders-procedural-clouds-01%2F&text=Procedural%202D%20Clouds%20%3A%20A%20mathematical%20approach%20to%20nature" target="_blank" rel="noopener noreferrer" class="text-text-secondary hover:text-text-primary transition-colors" aria-label="Share on Twitter"> <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"> <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"></path> </svg> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fvarungupta.dev%2Fblog%2Fshaders-procedural-clouds-01%2F" target="_blank" rel="noopener noreferrer" class="text-text-secondary hover:text-text-primary transition-colors" aria-label="Share on LinkedIn"> <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"> <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"></path> </svg> </a> </div> </div> </footer> </article>  </main> <footer class="border-t border-border mt-auto"> <div class="container py-12"> <div class="flex flex-col md:flex-row items-center justify-between gap-6"> <!-- Brand --> <div class="flex items-center gap-3"> <div class="w-8 h-8 rounded-lg bg-accent flex items-center justify-center font-bold text-white text-sm">
V
</div> <div> <p class="font-semibold text-text-primary">Varun Kumar Gupta</p> <p class="text-xs text-text-tertiary">© 2025</p> </div> </div> <!-- Built with --> <p class="text-sm text-text-tertiary">
Built with <a href="https://astro.build" target="_blank" rel="noopener noreferrer" class="hover:text-text-primary transition-colors">Astro</a> </p> </div> </div> </footer> <!-- Theme meta tag updater --> <script>
      function updateThemeColor() {
        const isDark = document.documentElement.classList.contains('dark');
        const metaThemeColor = document.querySelector('meta[name="theme-color"]');
        if (metaThemeColor) {
          metaThemeColor.setAttribute('content', isDark ? '#1F1F1F' : '#FFFFFF');
        }
      }
      
      // Update on load
      updateThemeColor();
      
      // Watch for theme changes
      const observer = new MutationObserver(updateThemeColor);
      observer.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['class']
      });
    </script> <!-- Scroll animations --> <script type="module">document.addEventListener("click",s=>{const t=document.createElement("div");t.className="click-spark",t.style.left=s.clientX+"px",t.style.top=s.clientY+"px";const c=8,o=Math.PI*2/c;for(let n=0;n<c;n++){const e=document.createElement("div");e.className="spark-particle";const a=o*n,l=30+Math.random()*20,p=Math.cos(a)*l,i=Math.sin(a)*l;e.style.setProperty("--tx",p+"px"),e.style.setProperty("--ty",i+"px"),e.style.left="-2px",e.style.top="-2px",t.appendChild(e)}document.body.appendChild(t),setTimeout(()=>{t.remove()},600)});</script> <!-- Click Spark Effect --> <script type="module">const a={root:null,rootMargin:"0px",threshold:.1},s=new IntersectionObserver(t=>{t.forEach(e=>{e.isIntersecting&&(e.target.classList.add("animate-slide-up"),e.target.classList.remove("opacity-0","translate-y-4"),s.unobserve(e.target))})},a);document.querySelectorAll("[data-animate]").forEach(t=>{t.classList.add("opacity-0","translate-y-4"),s.observe(t)});</script> </body> </html> <script type="module">function s(){const e=document.getElementById("toc-sidebar"),o=document.querySelector("footer.border-t");if(!e||!o)return;const n=e,c=o,d=128,r=32;function t(){const i=c.getBoundingClientRect(),a=window.innerHeight;if(i.top<a){const l=i.top-d-r;n.style.maxHeight=`${Math.max(l,100)}px`}else n.style.maxHeight="calc(100vh - 10rem)"}window.addEventListener("scroll",t,{passive:!0}),window.addEventListener("resize",t,{passive:!0}),t()}document.addEventListener("DOMContentLoaded",s);document.addEventListener("astro:page-load",s);</script>