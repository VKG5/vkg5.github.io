---
title: "PCG Notes #1: Hierarchical Tile-Based World Generation"
description: "A deep dive into building scalable procedural terrain systems using hierarchical chunking for unlimited world size."
publishedAt: 2025-12-01
category: procedural-generation
tags: [tutorial, unreal-engine, c++, terrain]
series: pcg-notes
seriesOrder: 1
featured: true
draft: false
---

Most procedural terrain systems make a critical mistake: they try to generate everything at once.

The result is predictable—either your worlds are small enough to fit in memory, or they're large but repetitive. Neither is good enough for modern open-world games.

In this article, I'll walk through a hierarchical tile-based approach that solves both problems. It's the system I developed for my recent project, and it handles worlds of essentially unlimited size while maintaining visual variety at every scale.

## The Problem with Flat Tile Systems

Traditional tile-based generation works something like this:

```cpp
for (int x = 0; x < worldSize; x++) {
    for (int y = 0; y < worldSize; y++) {
        GenerateTile(x, y);
    }
}
```

Simple, right? But there are two fundamental issues:

1. **Memory scales quadratically** — A 1000×1000 world is 1M tiles. A 10,000×10,000 world is 100M tiles.
2. **No macro-scale structure** — Each tile is generated independently, so you can't have continent-scale features without expensive global passes.

## Enter Hierarchical Chunking

The solution is to think in **levels of detail**, just like we do with mesh LODs. Instead of one flat grid, we use nested grids at different scales:

- **Level 0**: 16×16 meter tiles (detail)
- **Level 1**: 256×256 meter chunks (local features)
- **Level 2**: 4096×4096 meter regions (biomes)
- **Level 3**: 65536×65536 meter continents (macro structure)

Each level generates based on the level above it, creating coherent large-scale structure while only loading detail where needed.

## Implementation Overview

Here's the core architecture:

```cpp
class FHierarchicalTerrain {
public:
    void GenerateRegion(FIntVector2 RegionCoord, int32 LOD);
    
private:
    // Each level has its own noise configuration
    TArray<FNoiseConfig> LevelConfigs;
    
    // Cached chunks at each level
    TMap<FIntVector2, FTerrainChunk> ChunkCache[MAX_LEVELS];
};
```

The key insight is that higher levels act as **constraints** on lower levels. A Level 2 biome doesn't just influence the noise parameters—it defines the rules for what Level 1 and Level 0 can generate.

## Results and Performance

With this system, I achieved:
- **Unlimited world size** (tested up to 100km × 100km)
- **Constant memory usage** (~200MB regardless of world size)
- **Sub-frame generation** for new chunks (<2ms per chunk)

## Next Steps

In the next PCG Notes, I'll cover the specific noise functions and how to blend between biomes without visible seams.

The key takeaway: think hierarchically. Large-scale structure should inform small-scale detail, not the other way around.

---

*Have questions about this approach? Find me on Twitter or drop a comment below.*
